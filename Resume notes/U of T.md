- **Tell me about yourself**
	-  I've been working in the tech field for roughly over 5 years. The majority of the time was spent as a full-stack developer. 
	- The main focus in my career so far has been full stack development mainly in Angular and Typescript, and Spring Boot and Java. 
	- Over the years, I have worked on web applications that were either customer facing, or used by internal employees where we had opportunities to fix bugs or develop features based on feedback from the customers or users. We also had opportunities to take on larger projects such as the modernization of the UI of our application from AngularJS to Angular 12, and migration of the application to Microsoft Azure.
	- Generally in my roles, we would work collaboratively with other developers, QA testers, Product Owners, Project Managers and Scrum Masters in an Agile environment.
	- I believe one of my strongest qualities is my work ethic. I always strive to work hard for whatever work I do to make meaningful contributions for my team, and if I’m tasked with something I do not know how to do, I will make sure to find out how to do it. I know my commitment to my work ethic will carry over to U of T should I be hired.
- **Questions for hiring manager**
	- I can understand the need for updating from an outdated framework, but:
		- Why specifically Angular version 13? 
		- Is there a specific feature that will be useful for this Angular update? 
		- Are there plans to update to a higher Angular version in the future? Angular 16 or 17?
	- Where is the project currently? Has it started? What is the plan moving forward?
		- *Can talk about your experience with updating from AngularJS here*
	- What is the makeup of the current team? How does your team operate on a day-to-day-basis
	- What other projects are there lined up additionally to this current one? 
- **Why are you interested in this position**
	- I believe when you work in the tech field, you have to learn and continuously grow. And I am interested in this position because I have done the update from AngularJS to a higher version of Angular before and I know I would be able to contribute value to the project while being good way for me to do learn and grow
	- I am also interested in the position because I went to U of T for my degree, and I am interested in the opportunity to give back to the university that I went to
- **Angular 13 features**
	- Support for Ivy as a view engine:
		- What is Ivy?
		- What is a view engine?
	- No IE 11 support
	- Angular 13 adds RxJS 7.4
	- Router updates
		- routerLink directive value to null or undefined will now completely disable the navigation
	- Easier to dynamically create a component (i.e. `this.viewContainerRef.createComponent(myComponent))`
- **What is your experience at TD?** (i.e. go over that section of your resume in depth)
	- In the role, I got to work on modernizing a legacy application which used AngularJS and Spring Boot to use Angular v12 instead. The project was basically rewriting the entire frontend (creating new pages, components, etc.), but keeping the features of the application the same. A major decision I made when working on this project was to migrate most to all of the logic (e.g. business logic, calls to APIs, formatting data, error handling) to the backend because I believe that the frontend should be for just displaying the data.
		- 
		- **Learning Lessons from this (VERY IMPORTANT):**
			- Do not need to focus so much on creating reusable components
				- Yes that is the goal. However, there may be situations where it doesn't work easily or well, and you end up creating a component that ends up being hard to work with or understand (especially for newer developers to the project) or not as easily maintainable or extendable 
			- Keep track of all the features that the current application has that you are planning on bringing over to the new application:
				- I think a combination of trying to develop the application quickly, and too much focus on trying to develop the perfect components made us unaware we were missing a feature from the final application.
				- So later on, we received an incident where a user wasn't sure why a specific row of data wasn't appearing correctly. It turns out it was because we missed a feature where we had to display a banner for certain conditions that would cover the situation that user was facing
	- I also got to work on a major cost saving initiative involving integration with an API that provides information about the retail branches. The interesting thing about this project and the reason why it would end up saving costs is because in our codebase, we maintained the information in a .txt file. This was supposed to be a temporary solution due to a deprecation of their previous solution. However, the .txt file was maintained for years so every time there would be additions such as new retail branch locations or updates to the retail branch information such as an address or phone number changes, we would have to make the update to the .txt file, deploy it to our lower environments, then schedule a deployment for our higher environments. With the new API, all of that data was made available to us. We then had to filter and format the data to be useable in our application, schedule a daily API call so the data could be retrieved automatically, and store it inside of a cache (we used an in memory cache provided by the Spring Framework).
	- Additionally, I was able to identify an opportunity to leverage a design pattern for reducing code duplication (i.e. decorator pattern). It started when we had to include new validation for the branch ID. I noticed the current implementation would have multiple functions doing the same thing, and if I wanted to extend it to include the new validation, I’d have to increase the code duplication. From the frontend, there were multiple methods making API calls to the same endpoint but with a different query parameter. So I updated the code to one method that can dynamically generate a query parameter string based on different values in a map depending on the necessary validation. I also leveraged the “type” keyword (from typescript) for specifying the possible keys for the map, so another developer could extend this type to include more keys in the future which would result in more query parameters at the end of the API call (and so more validation). In the backend, I also saw some conditions in the code that eventually resulted to the same validation being called. If we were to extend this functionality, we would need to add a new condition and duplicate the code again. In order to reduce the code duplication and make the code extendable, I introduced the **Decorator Pattern** initially to add new functionality to existing functionality. I think of decorator pattern like wrapping a class around another class and providing new functionality. In the case of our validation, we wanted to validate the branch ID against multiple lists with one list always being validated against, so this pattern made sense. I created a concrete validator class as my base which would validate the branch ID against one list, and two decorator classes which would validate the branch ID against other lists. We also used the **Factory Pattern** to figure out which decorators to add to the base concrete validator. I realized though what I was really doing was chaining different validation together. So I learned about something called the **Chain of Responsibility Pattern** where we would have handlers which validate the branch ID and pass it to the next handler if the validation didn’t return true, and I refactored the code to use this pattern instead. In the end, by using the design patterns, the code duplication was gone and our code was simplified while being able to provide more functionality.
	- The major thing I’m working on now is leading the migration for one of our applications to Microsoft Azure. There are a lot of challenges with this, such as updating how we are maintaining our config (i.e. previously we externalized our config to a location on the server, but now we are bringing it back into the codebase), making sure our unit tests have enough code coverage, connecting with databases and whether it will work (e.g. IBM DB2 database, IMS), connecting to many APIs, configuring the CI/CD pipeline, integration with Datadog for logging and monitoring, leveraging Redis for session management (and potentially other uses), leveraging Vault for secrets, potentially leveraging an Azure service called App Config (issue because it has a specific use case for key-value pairs). We are only at the beginning stages of this project, so a lot of the work will be done in the coming weeks to months.