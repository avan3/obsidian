- **Static keyword**
	- Property or method belongs to the class itself
	- Does not need to be instantiated to use the property or method
	- Only one instance of that property or method, cannot have multiple instances
	- Cannot override a static method in Java
- **Class vs Object**
	- Class is a user-defined data type that can be used to create an object. It includes properties and methods. It is essentially a blueprint for creation of an object
	- An Object is an instance of the class 
- **Interface vs Abstract class**
	- Abstract classes is a class that can contain both abstract methods (methods without implementation) and concrete methods 
		- Can only extend from one abstract class
	- Interface has no concrete methods, only abstract methods 
		- Class implement from multiple interfaces
- **Pass by value vs Pass by reference**
	- Pass by value is only passing in the value itself and any modifications made to the value inside of the method is not changed for outside the method
	- Pass by reference is passing the reference for the variable itself, so changes made to the variable are updated for outside the method as well
	- JAVA IS PASS BY VALUE
- **Difference between == and .equals**
	- == compares the references 
	- equals() will check the contents of the object
- **Hashcode and equals**
	- equals() is used to compare two objects
	- hashCode() returns an integer that represents the current instance of the class
	- I believe you can use the hashcode generated to determine whether two objects are equal
- **What is Serializable**
	- Extending Serializable allows the object to be converted into a byte stream (serialization) which then can be converted back into an object (deserialization)
	- SerialVersionUID - a class version that is used to verify that the current version of the class is compatible during deserialization (can be backwards compatible)
- **Local, instance, and class variables**
	- Local variable: declared within a code block such as a method 
	- Instance variables: declared inside a class but outside of a method
	- Class variables: declared with the static keyword in a class, but outside a method, constructor or code block
- **Synchronized keyword**
	- 
- **Autoboxing vs Unboxing**
	- Conversion between primitive types and their corresponding object wrapper classes
- **Widening vs Narrowing**
	- Widening is when you pass a smaller data type into a larger size type
	- Narrowing is the opposite
- **Transient and Volatile**
	- 
- **Characteristics of OO programming languages**
	- Abstraction
		- Hiding away information, and only exposing what is necessary
		- E.g. a user doesn't need to know about how a car runs, they just need to be able to drive the car
	- Encapsulation
		- Grouping functions and data into a single entity
		- Accessing the data or methods is determined by access controls (i.e. private, protected, public keywords)
	- Inheritance 
		- Creating a new class from an existing class
		- Subclass is created from Superclass (parent-child relationship) where subclass inherits can inherit the properties and methods from the superclass depending on the appropriate access controls (i.e. protected and public, but not private)
	- Polymorphism
		- Multiple classes are able to use the same method name
		- Overloading vs Overriding:
			- Overloading is defining multiple methods with the same name but different parameters within the same class
			- Overriding is when a subclass has it's own implementation and overrides the implementation by the superclass
- **Memory leaks in Java**
	- Memory leak is when an object or objects is no longer used but cannot be removed by the garbage collector. This can lead to performance degradation, running out of memory
	- E.g. not closing a connection to a database, or not closing an input stream
		- Reference to the objects will still exist preventing garbage collection
- **JUNIT**
- **JAVA WEB SERVICES**
- **MAVEN**
	- Build tool: tool to compile, test, and package your application (i.e. jar, war, ear)
	- Provides a default project structure, and pom.xml (**Project Object Model** config file which includes information about the project (including groupId, artifactId), versioning, dependencies, plugins)
- **GRADLE**
- **Garbage collection**
	- Process by which Java programs perform automatic memory management
		- When Java program runs on JVM, objects are created on the heap.
		- Garbage collection looks at the heap and identifies the objects which are in use and which are not and deleting the unused objects
			- Unused means the application does not maintain a pointer to that object
		- A used object, or referenced object, means that some part of your program still maintains a pointer to that object
	- Mark-and-Sweep GC algorithm:
		- Mark phase:
			- Marks unreferenced objects mark bit to 0, while referenced objects mark bit is set to 1
		- Sweep phase:
			- Clears the heap memory for all of the unreachable objects
	- Types:
		- Minor or incremental: occurs when unreachable objects in the younger heap are removed
		- Major or full: occurs when the objects that survived the minor garbage collection are copied to the old generation or permanent generation heap memory are removed (occurs less frequently)
	- How to make an object eligible for garbage collection:
		- Nullify the reference variable:
		- Re-assigning the reference variable:
		- An object created inside the method: object reference is garbage collected after method execution?
		- Island of isolation: objects that are referenced by each other but not in any other part of the application
	- Can manually run garbage collection:
		- When we make an object eligible for garbage collection, it may not immediately be destroyed
		- We can request JVM to run garbage collection:
			- System.gc() method
			- Runtime.getRuntime().gc() method
			- Finalize():
				- Method to perform cleanup activities such as releasing all the resources used by the object before it is deleted/destroyed by the garbage collector
				- Is not a reserved keyword, **it is a method!**
				- Once method completes, garbage collection destroys that object
				- Never run more than once for any object
				- If uncaught exception is thrown, the exception is ignored and the finalization of the object terminates
	- Memory Leak:
		- Objects exist on the heap but the garbage collector is unable to remove them from memory
		- **Blocks memory resources and degrades system performance over time**
		- Garbage collection removes unreferenced objects periodically, but it never collects the objects that are still being referenced. This is where memory leaks can occur
		- Symptoms:
			- **Performance degradation**
			- **OutOfMemoryError**
			- Spontaneous and strange **application crashes**
		- Through:
			- Static fields:
			- Have a life that usually matches the entire lifetime of the running application
				- Try to lazy load not eagerly load if you must use static
			- Unclosed resources:
				- Forgetting to close resources such as an open stream (e.g. database connections, input streams, session objects)
			- Improper equals() and hashCode() implementations:
				- In a map, there shouldn’t be duplicate keys but if you pass in multiple objects with the same key and the equals() method is not implemented correctly, can increase the memory (will not know it’s a duplicate object and keep putting in the object into the map thereby increasing memory)
- **Synchronization:**
	- Synchronized keyword: used to specify that a code block can only have one thread executing at a time. Other threads attempting to execute that coed block are blocked until the thread currently executing exits the code block
- **What is static keyword?**
	- Adding the static keyword to a variable or method means that variable/method belongs to the type/class itself rather than the instance of the type/class
	- When declaring a field static, exactly one copy of that field is created and shared among all instances of that class
	- **Static methods cannot be overridden**
	- Abstract methods cannot be static
	- Static methods can’t use this or super keywords
	- **Static methods can only access static fields**
	- **Static methods can’t access instance variables and instance methods directly. They need some object reference to do so**
- **Final vs finally vs finalize:**
	- Final (keyword): cannot modify its value. Also, cannot be overridden by a subclass
	- Finally (block) is the block in the try catch block that always executes at the end
		- Does not execute on system.exit() or system crash
	- Finalize (method): look above at garbage collection section