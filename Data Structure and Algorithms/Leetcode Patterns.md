![[Pasted image 20250403115411.png]]![[Pasted image 20250403115913.png]]
Linear:
- Two pointers:
	- Can go in same direction:
		- Processing or scanning the data in a single pass
		- E.g. Fast-slow pointer approach to find a cycle or the middle of the list
	- Or opposite direction:
		- Used for finding pairs of comparing elements from opposite ends of the data structure
		- E.g. Find two numbers in a sorted array that sum up to a target value (i.e. Two Sum II)
- Sliding Window:
	- Maintaining a window of elements within the data dynamically adjusting the size as you progress through the data structure
	- Uses two pointers, but goal is to manage a subset of elements that satisfy a specific condition
		- One pointer marks the start of the window, the other pointer marks the end
	- E.g.  longest substring without repeating characters
- Binary Search:
	- Allows you to find a target value in a sorted array by repeatedly dividing the array in half
	- Uses two pointers
	- Useful for monotonic function - any type of pattern where there is a consistent increase or decrease 
	- Also useful for finding the first true occurrence (i.e. if the array had only true and false)
		- E.g. Find Minimum in Rotated Sorted Array
			- Any element lower than the last element in the array is part of the rotated section
			- Any element greater than the last element in the array is part of the original sorted section
Non-Linear:
- Data Structures:
	- Trees 
		- Trees are graphs with no cycles
	- Graphs
		- Have cycles
		- Need a visited set to keep track of nodes you've already visited
- Breadth-First Search (BFS):
	- Use to explore nodes in a graph or tree level-by-level
		- Starts at a node (root) then moves to immediate neighbours before moving onto their neighbours
	- Uses a queue:
		- First in, First out (FIFO)
	- Best for shortest path
	- E.g. Binary Tree Level Order Traversal
- Depth-First Search (DFS):
	- Use to explore nodes in a graph as deep as possible into the tree before exploring the next path
	- Uses a stack:
		- Last in, First out (LIFO)
		- Usually the call stack (recursive), or instantiated (iterative)
	- Best for exploring all paths
		- Not suited for finding shortest path because it doesn't guarantee finding the closet solution first
	- E.g. Number of Islands
- Backtracking:
	- Extension of DFS
	- Have to built the solution tree yourself
		- Can be generated dynamically as you make decisions
		- E.g. including something or not including something (combinations, subsets, permutations)
		- Adding the next value to the potential solution, calling DFS with the next index, then popping that same value from the potential solution
	- E.g. Letter combinations of a phone number 
	- ![[Pasted image 20250403171547.png]]
	- Time complexity O(4^n) --> the digit is how many branches we can go down - usually 2 (like if we include something or not include something)
- Priority Queue (Heap):
	- When you see a question that says "Top K", "K largest", or "K smallest", use a priority queue
	- Special type of tree where the smallest value is at the top and each parent is smaller than its children (i.e. Min Heap), or the largest value is at the top and each parent is larger than its children (i.e. Max Heap)
	- Use a Min Heap to find the K largest values, and a Max Heap to find the K smallest values
	- E.g. Find 3 smallest values in a list
		- Instantiate a Max Heap with a size of 3 items
		- Add 3 items to Max Heap
		- Next item, check if next number is smaller than previous largest value 
		- If it is, remove value at root, then insert new value
	- Use when you need to know where the largest or smallest value is
	- Time Complexity - to insert or remove O(log n)
- Dynamic Programming:
	- Involves optimizing a solution by breaking it down into overlapping subproblems, storing the result of the subproblems and reusing them to avoid redundant computations
	- Top-Down:
		- Start from the main problem and recursively solve it's subproblems, storing the result of the subproblem to avoid solving the same subproblem multiple times 
		- Backtracking + Memoization:
			- Memoization is saving the previous function call result in a dictionary and reading from it when we do the exact same call again
	- Bottom-Up:
		- Solve the smallest subproblem first and use their solution to build up to the solution for the larger problem
		- Instead of using recursion, it involves filling in a table where each entry represents the solution to a smaller subproblem 
		- Start with base cases and iteratively compute the solutions to progressively larger subproblems until you reach the final solution 
		- Avoids the overhead of recursion and memoization often resulting in more efficient time and space usage
		- Commonly used when you know the dependencies between subproblems and can structure the solution iteratively 